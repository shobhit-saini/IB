/*
Given a binary tree and a sum, find all root-to-leaf paths where each pathâ€™s sum equals the given sum.

For example:
Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
return

[
   [5,4,11,2],
   [5,8,4,5]
]
Seen this question in a real interview before
*/
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int j = 0, k = 0;
int len;

void find_path(TreeNode* A, int pathlen, int B, int* arr, vector<vector<int>>&result)
{
    int i, sum = 0;
    if(A == NULL)
        return;
    arr[pathlen] = A->val;
    pathlen++;
    if(A->left == NULL && A->right == NULL)
        {
            for(i = 0; i < pathlen; i++)
            {
                sum = sum+arr[i];
            }
            if(sum == B)
            {
                for(i = 0; i < pathlen; i++)
                {
                    result[j].push_back(arr[i]);
                }
                j++;
            }
        }
    else
    {
        find_path(A->left, pathlen, B, arr, result);
        find_path(A->right, pathlen, B, arr, result);
    }
    
}
int maxDepth(TreeNode* A, int k) {
    if(A == NULL)
    {
        return 0;
    }
    int dl = maxDepth(A->left, k++);
    int dr = maxDepth(A->right, k++);
    if(dl < dr)
    {
        return dr+1;
    }
    else
        return dl+1;
}
vector<vector<int> > Solution::pathSum(TreeNode* A, int B) {
    int len = maxDepth(A, k);
    int arr[len];
    vector<vector<int>>result(100000);
    find_path(A, 0, B, arr, result);
    vector<vector<int>> res(j);
    for(int i = 0; i < j; i++)
    {
        res[i] = result[i];
    }
    return res;
}
